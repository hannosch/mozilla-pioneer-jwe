"""
Based on JWE / JSON Web Encryption (https://tools.ietf.org/html/rfc7516) and
JWK / JSON Web Key (https://tools.ietf.org/html/rfc7517)

Client side we used the js-jose library (https://github.com/square/js-jose),
and on the server side a Python library called jwcrypto
(https://github.com/latchset/jwcrypto/tree/master/jwcrypto).

The following is an example to play around with the data flow and
cross-validate the generated encrypted data.

Copy this file and the Dockerfile into a new directory and on shell
prompt ($ prefix) run:

$ docker build -t jwe .
$ docker run -it --rm jwe

This drops you into a Python interactive prompt (>>> prefix).

>>> import main

Input data is any binary data, for example a stringified JSON mapping,
encoded as UTF-8:

>>> data = b'{"user": 1, "values": ["something"]}'
>>> ciphertext = main.encrypt(data)

>>> ciphertext
'eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00iLCJ6aXAiOiJERUYifQ.dD47j10na7mW-XysXXvKL8gHFy6fWJ3kqrerDutPXg3nO-yfIis5CYYOZgaTgONt9h7crcvdv8l84WyIgWiB-9pjnwcU0CsCNu-1zj7JCm3w-o-Nn8d458ftTenvHGsbE05vCSAjmy9sRDdF2fBLMHAUqQcYJIWTWTbEVGUT_UwDUwSPRVO_DflajIf3teTS_Smht8RJrJIHbI4ZNXV5jmFAWhvwVYy7d_mHbAgexGDzPAuTvo84tHJ2RixC-xD4mZcgXDV6yMZmgk23-qFi7JzuS-A4zIQM1oaOKrZ5-yoZM2HD50A14UHCxHeWegsAYqKe0ErpuijoZpPwI6-_mQ.nsrYJQN6PwBMpejO.GtGjv3hj3P_5VNiagu8TNjp7AKW5MWHBIokDIJYoi-8Ag_Ga.D1-nkV0xKMT34OBd3rembw'

We can validate the general structure and the header info without
knowing any of the key material:

>>> main.validate(ciphertext)
'valid compressed'

The ciphertext in the compact representation is a concatenation of
five values, delimited by a dot, the first is the general header.

These parts are base64 encoded, but with padding values removed, so
they need to be reconstructed, which is done by the helper function
from jwcrypto.common.base64url_decode. The first part is the public
general header:

>>> from jwcrypto.common import base64url_decode
>>> base64url_decode(ciphertext.split('.')[0])
b'{"alg":"RSA-OAEP","enc":"A256GCM","zip":"DEF"}'

We can also disable compression:

>>> ciphertext2 = main.encrypt(data, compress=False)

And decode the header again:

>>> base64url_decode(ciphertext2.split('.')[0])
b'{"alg":"RSA-OAEP","enc":"A256GCM"}'

Knowing the private key, we can again decrypt the data:

>>> main.decrypt(ciphertext)
'{"user": 1, "values": ["something"]}'

In order to play with the keys, we can export them in the JWE format:

>>> main.PUBLIC_JWK.export_public().encode('utf-8')
b'{"e":"AQAB","kty":"RSA","n":"or0Toco3aoGeB0aBBCCZsCp80Nymi7Qi1RKuA-A5xJi8YGDK_Ju5jh6C0qc6TX1DCfoFT1aAZKsvZ23O7Rg68OAE6fmhZPcXYf3t5sgFgBqOHjnLY2DfmJEfYO5L426ALobJ4SULTYFgs0lI-4aOJ26MRrMc0skesDmbi0lr14DoDUfMijldgJB568Y9QO_5wfHr7b6mq9fF2fOGTHC8zjwv_Cb89b_mpXw9_4m4OSUy2_64xEDc3HQeKadU4yl16N1f3GawjmR_7ywqsc4qjx5CMby8lZysAptHHvoD4YuTS8_Th1IcK5JdwG_9-RmbgqLn7OQHRziP93JVXvGkaQ"}'

>>> main.PRIVATE_JWK.export_private().encode('utf-8')
b'{"d":"f_HRboDygpz3Zlbq9hi_W_57dSYVFn8AZ66w-0EdidBfQhK3ZFT2VKLuTbnGH8gcncpgxFiIxxzDPzjY2BUVue0WT_HADwYo7xTaJngZwvadx2u-2Rn_kQ5_shCHv35P7sRwEb-zHDNcmHhElePa_Wtvg-IsBhizNO-Ft8N4sstYInCfesn9YdJT1Ih9tG1cIzw-NuHEKLh0PrgHHU0i_iy1yf1vm7kAz9fzd5jxZ0GVawDxDxmRje1c9MFcNsc5NDu3rgSKT92HMNS0FYWorr7vYtL2ClvY7j3W9dt0C4ArTgKGTj9L3eJ3viH-QGAAbBeKMvGbXqDm8i5sY7JKAQ","dp":"VQhywYpoTARaW-W5G9_DhYsM5DuIs4qSqScH5w-mBrDHgWO2cIMJTtddxExY2MKlX23UK6CKq0NuAR1WS7C-S7ajKUF4vUoNRetk1WEbboNCeKheyLydBu-1ZH2louQ4NoFFYMJfj0q8kQAyrY09Q5fXL6lSes3JTABbNdqXwEE","dq":"kneQpLdZhzmamRKxsNeM0BLXI87y21ww6gLFp4jGIlzVWXwxSfWbYS7zUI-_-TCtSKxtxgbIZqAlOZFRMF3TuHcgDdbpdk2G1TcovkD7PCNfBMPvyaNioE23paz9Ti2ap_x_W8pwaYmNLm8ZjuE2SLjbpanBettAZp2iz1JgFiE","e":"AQAB","kty":"RSA","n":"or0Toco3aoGeB0aBBCCZsCp80Nymi7Qi1RKuA-A5xJi8YGDK_Ju5jh6C0qc6TX1DCfoFT1aAZKsvZ23O7Rg68OAE6fmhZPcXYf3t5sgFgBqOHjnLY2DfmJEfYO5L426ALobJ4SULTYFgs0lI-4aOJ26MRrMc0skesDmbi0lr14DoDUfMijldgJB568Y9QO_5wfHr7b6mq9fF2fOGTHC8zjwv_Cb89b_mpXw9_4m4OSUy2_64xEDc3HQeKadU4yl16N1f3GawjmR_7ywqsc4qjx5CMby8lZysAptHHvoD4YuTS8_Th1IcK5JdwG_9-RmbgqLn7OQHRziP93JVXvGkaQ","p":"0EZWwkCZS8WfRijwlS-rZZDAkdBrdE5mFWPi26X_ntvAEivCsWqXPkgqIeibzymD2gc1yxkZPzuvaGehZ88IbvRnIzlvJ2qd9ewRfzg8ikIfGAhC1KS7hTxYjzycpU60ONh-io4yUoODxZtTpaSUdWyNQEocpYWX3UQuQHIF00E","q":"yAeHHjG1sO-D0r9hQlk5zfAI07ZKA8sPaxNlIuFd18VnCRPAyPYw_LR2ucpxWyQTVwywL2VqD4mXR2mpll5LySy__Thv4pcFEmeRJzVVUWZLBwlDkQ5MXpMmtIHXIcttDJBfug-6SVSEADx5RzjPS0yxcckG6sAmlxwnPzYiDyk","qi":"R1mCjah_uyIZE4_m5L0rTrARa7doAD6lb9dXGcf2VUZQWKfNSNSDv69SCHY_i29CvquwXLCrya_eXeJYuyAVdpZ5uImlMWzIlcJ8et-ZdBveX3gHi4MhXBhLujEIJjMHDKjXB9YV5WQCllMNMeZnn8io9INetqlZhYBYZqDtuM4"}'

At the very end, Ctrl+D to get out of the interactive prompt.
Deleting the docker image works via:

$ docker rmi jwe
"""

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from jwcrypto.jwe import JWE
from jwcrypto.jwk import JWK


backend = default_backend()

# Data generated by:
# openssl genrsa -out private.key 2048
PRIVATE_KEY = b'-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAor0Toco3aoGeB0aBBCCZsCp80Nymi7Qi1RKuA+A5xJi8YGDK\n/Ju5jh6C0qc6TX1DCfoFT1aAZKsvZ23O7Rg68OAE6fmhZPcXYf3t5sgFgBqOHjnL\nY2DfmJEfYO5L426ALobJ4SULTYFgs0lI+4aOJ26MRrMc0skesDmbi0lr14DoDUfM\nijldgJB568Y9QO/5wfHr7b6mq9fF2fOGTHC8zjwv/Cb89b/mpXw9/4m4OSUy2/64\nxEDc3HQeKadU4yl16N1f3GawjmR/7ywqsc4qjx5CMby8lZysAptHHvoD4YuTS8/T\nh1IcK5JdwG/9+RmbgqLn7OQHRziP93JVXvGkaQIDAQABAoIBAH/x0W6A8oKc92ZW\n6vYYv1v+e3UmFRZ/AGeusPtBHYnQX0ISt2RU9lSi7k25xh/IHJ3KYMRYiMccwz84\n2NgVFbntFk/xwA8GKO8U2iZ4GcL2ncdrvtkZ/5EOf7IQh79+T+7EcBG/sxwzXJh4\nRJXj2v1rb4PiLAYYszTvhbfDeLLLWCJwn3rJ/WHSU9SIfbRtXCM8PjbhxCi4dD64\nBx1NIv4stcn9b5u5AM/X83eY8WdBlWsA8Q8ZkY3tXPTBXDbHOTQ7t64Eik/dhzDU\ntBWFqK6+72LS9gpb2O491vXbdAuAK04Chk4/S93id74h/kBgAGwXijLxm16g5vIu\nbGOySgECgYEA0EZWwkCZS8WfRijwlS+rZZDAkdBrdE5mFWPi26X/ntvAEivCsWqX\nPkgqIeibzymD2gc1yxkZPzuvaGehZ88IbvRnIzlvJ2qd9ewRfzg8ikIfGAhC1KS7\nhTxYjzycpU60ONh+io4yUoODxZtTpaSUdWyNQEocpYWX3UQuQHIF00ECgYEAyAeH\nHjG1sO+D0r9hQlk5zfAI07ZKA8sPaxNlIuFd18VnCRPAyPYw/LR2ucpxWyQTVwyw\nL2VqD4mXR2mpll5LySy//Thv4pcFEmeRJzVVUWZLBwlDkQ5MXpMmtIHXIcttDJBf\nug+6SVSEADx5RzjPS0yxcckG6sAmlxwnPzYiDykCgYBVCHLBimhMBFpb5bkb38OF\niwzkO4izipKpJwfnD6YGsMeBY7ZwgwlO113ETFjYwqVfbdQroIqrQ24BHVZLsL5L\ntqMpQXi9Sg1F62TVYRtug0J4qF7IvJ0G77VkfaWi5Dg2gUVgwl+PSryRADKtjT1D\nl9cvqVJ6zclMAFs12pfAQQKBgQCSd5Ckt1mHOZqZErGw14zQEtcjzvLbXDDqAsWn\niMYiXNVZfDFJ9ZthLvNQj7/5MK1IrG3GBshmoCU5kVEwXdO4dyAN1ul2TYbVNyi+\nQPs8I18Ew+/Jo2KgTbelrP1OLZqn/H9bynBpiY0ubxmO4TZIuNulqcF620BmnaLP\nUmAWIQKBgEdZgo2of7siGROP5uS9K06wEWu3aAA+pW/XVxnH9lVGUFinzUjUg7+v\nUgh2P4tvQr6rsFywq8mv3l3iWLsgFXaWebiJpTFsyJXCfHrfmXQb3l94B4uDIVwY\nS7oxCCYzBwyo1wfWFeVkApZTDTHmZ5/IqPSDXrapWYWAWGag7bjO\n-----END RSA PRIVATE KEY-----\n'

# Data generated by:
# openssl rsa -pubout -in private.key -out public.key
PUBLIC_KEY = b'-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAor0Toco3aoGeB0aBBCCZ\nsCp80Nymi7Qi1RKuA+A5xJi8YGDK/Ju5jh6C0qc6TX1DCfoFT1aAZKsvZ23O7Rg6\n8OAE6fmhZPcXYf3t5sgFgBqOHjnLY2DfmJEfYO5L426ALobJ4SULTYFgs0lI+4aO\nJ26MRrMc0skesDmbi0lr14DoDUfMijldgJB568Y9QO/5wfHr7b6mq9fF2fOGTHC8\nzjwv/Cb89b/mpXw9/4m4OSUy2/64xEDc3HQeKadU4yl16N1f3GawjmR/7ywqsc4q\njx5CMby8lZysAptHHvoD4YuTS8/Th1IcK5JdwG/9+RmbgqLn7OQHRziP93JVXvGk\naQIDAQAB\n-----END PUBLIC KEY-----\n'

# Load RSA keys into JWK compatible API
_private_key = serialization.load_pem_private_key(
    PRIVATE_KEY, password=None, backend=backend)
PRIVATE_JWK = JWK()
PRIVATE_JWK.import_from_pyca(_private_key)

_public_key = serialization.load_pem_public_key(
    PUBLIC_KEY, backend=backend)
PUBLIC_JWK = JWK()
PUBLIC_JWK.import_from_pyca(_public_key)


def encrypt(plaintext, compress=True):
    # Encrypt the plaintext with the public key, using RSA-OAEP / AES 256 GCM
    jwe = JWE(plaintext=plaintext,
              protected='{"alg":"RSA-OAEP","enc":"A256GCM"}')
    if compress:
        header = '{"zip":"DEF"}'
    else:
        header = None
    jwe.add_recipient(PUBLIC_JWK, header=header)
    ciphertext = jwe.serialize(compact=True)
    return ciphertext


def decrypt(ciphertext):
    # Decrypt the cyphertext using the private key, automatically
    # handling zip decompression, based on the presence of the zip
    # header field.
    jwe = JWE()
    jwe.deserialize(ciphertext, key=PRIVATE_JWK)
    plaintext = jwe.payload.decode('utf-8')
    return plaintext


def validate(ciphertext):
    # Validate the general ciphertext JWE structure without any knowledge
    # of the involved keys.
    jwe = JWE()
    jwe.deserialize(ciphertext)
    if jwe.jose_header == {'alg': 'RSA-OAEP', 'enc': 'A256GCM', 'zip': 'DEF'}:
        return 'valid compressed'
    elif jwe.jose_header == {'alg': 'RSA-OAEP', 'enc': 'A256GCM'}:
        return 'valid uncompressed'
    return 'invalid'
